
/*
 * Copyright [2016] [Subhabrata Ghosh]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
%token ${type}
%token ${type_ptr}
%token ${name}
%token ${m_name}
%token ${key_type}
%token ${value_type}
%token ${value_type_ptr}
%token ${return}
%token ${data_var}
%token ${set_map_calls}
%token ${read_map_calls}
%token ${includes}
%token ${nested}
%token ${parent}
%token ${declarations}
%token ${private_functions}
%token ${constructor}
%token ${destructor}
%token ${public_functions}
%token ${header}
%token ${version}
%token ${username}
%token ${date}
%token ${guard_name}
%token ${body}
%token ${variable_inits}
%token ${variable_frees}
%token ${schema_name}
%token ${free_data_calls}

VARIABLE_NATIVE_DEF:
${type} ${name} = nullptr;
;;

VARIABLE_NATIVE_FREE:
if (this->__is_allocated) {
	FREE_PTR(this->${name});
}
;;

VARIABLE_TYPE_FREE:
CHECK_AND_FREE(this->${name});
;;

VARIABLE_LIST_NATIVE_FREE:
if (this->__is_allocated) {
	FREE_NATIVE_LIST(this->${name});
} else {
	this->${name}->clear();
	CHECK_AND_FREE(this->${name});
}
;;

VARIABLE_LIST_TYPE_FREE:
FREE_TYPE_LIST(this->${name});
;;

VARIABLE_MAP_NATIVE_FREE:
if (this->__is_allocated) {
	FREE_NATIVE_MAP(this->${name});	
} else {
	this->${name}->clear();
	CHECK_AND_FREE(this->${name});
}
;;

VARIABLE_MAP_TYPE_FREE:
FREE_TYPE_MAP(this->${name});
;;

FUNC_GETTER_DEF:
const ${return} get_${name}(void) const {
    return this->${name};
}
;;

FUNC_SETTER_PTR_DEF:
void set_${name}(${type} ${name}) {
    this->${name} = ${name};
}
;;

FUNC_NATIVE_SETTER_DEF:
void set_${name}(${type} &${name}) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->${name});
    this->${name} = (${type_ptr})malloc(sizeof(${type}));
    CHECK_ALLOC(this->${name}, TYPE_NAME(${type}));
    *(this->${name}) = ${name};
}
;;

FUNC_STRING_SETTER_DEF:
void set_${name}(string &${name}) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->${name});
    if (!IS_EMPTY(${name})) {
        uint32_t __size = ${name}.length() + 1;
        this->${name} = (char *) malloc(sizeof(char) * __size);
        CHECK_ALLOC(this->${name}, TYPE_NAME(char *));
        memset(this->${name}, 0, __size);
        memcpy(this->${name}, ${name}.c_str(), (__size - 1));
    }
}
;;

FUNC_LIST_NATIVE_ADD_DEF:
void add_to_${name}(${type} &${name}) {
    PRECONDITION(this->__is_allocated == true);
    if (IS_NULL(this->${name})) {
        this->${name} = new std::vector<${type_ptr}>();
        CHECK_ALLOC(this->${name}, TYPE_NAME(vector));
    }
    ${type_ptr} __var = (${type_ptr})malloc(sizeof(${type}));
    CHECK_ALLOC(__var, TYPE_NAME(${type}));
    *__var = ${name};
    this->${name}->push_back(__var);
}
;;

FUNC_LIST_STRING_ADD_DEF:
void add_to_${name}(string &${name}) {
    PRECONDITION(this->__is_allocated == true);
    if (IS_NULL(this->${name})) {
        this->${name} = new std::vector<${type_ptr}>();
        CHECK_ALLOC(this->${name}, TYPE_NAME(vector));
    }
    if (!IS_EMPTY(${name})) {
        uint32_t __size = ${name}.length() + 1;
        char *__var = (char *)malloc(sizeof(char) * __size);
        CHECK_ALLOC(__var, TYPE_NAME(char *));
        memset(__var, 0, __size);
        memcpy(__var, ${name}.c_str(), (__size - 1));
        this->${name}->push_back(__var);
    }
}
;;

FUNC_LIST_TYPE_ADD_DEF:
void add_to_${name}(${type_ptr} ${name}) {
    PRECONDITION(this->__is_allocated == true);
    CHECK_NOT_NULL(${name});
    if (IS_NULL(this->${name})) {
        this->${name} = new std::vector<${type_ptr}>();
        CHECK_ALLOC(this->${name}, TYPE_NAME(vector));
    }
    this->${name}->push_back(${name});
}
;;

FUNC_MAP_NATIVE_ADD_DEF:
void add_to_${name}(${key_type} m_key, ${value_type} &m_value) {
    PRECONDITION(this->__is_allocated == true);
    if (IS_NULL(this->${name})) {
        this->${name} = new std::unordered_map<${key_type}, ${value_type_ptr}>();
        CHECK_ALLOC(this->${name}, TYPE_NAME(unordered_map));
    }
    ${value_type_ptr} __var = (${value_type_ptr})malloc(sizeof(${value_type}));
    CHECK_ALLOC(__var, TYPE_NAME(${value_type}));
    *__var = m_value;
    this->${name}->insert({m_key, __var});
}
;;

FUNC_MAP_STRING_ADD_DEF:
void add_to_${name}(${key_type} m_key, string &m_value) {
    PRECONDITION(this->__is_allocated == true);
    if (IS_NULL(this->${name})) {
        this->${name} = new std::unordered_map<${key_type}, ${value_type_ptr}>();
        CHECK_ALLOC(this->${name}, TYPE_NAME(unordered_map));
    }
    CHECK_NOT_EMPTY(m_value);
    uint32_t __size = (m_value.length() + 1) * sizeof(char);
    char *__var = (char *)malloc(sizeof(char) * __size);
    CHECK_ALLOC(__var, TYPE_NAME(char *));
    memset(__var, 0, __size);
    memcpy(__var, m_value.c_str(), (__size - 1));
    this->${name}->insert({m_key, __var});
}
;;

FUNC_MAP_TYPE_ADD_DEF:
void add_to_${name}(${key_type} m_key, ${value_type_ptr} m_value) {
    PRECONDITION(this->__is_allocated == true);
    if (IS_NULL(this->${name})) {
        this->${name} = new std::unordered_map<${key_type}, ${value_type_ptr}>();
        CHECK_ALLOC(this->${name}, TYPE_NAME(unordered_map));
    }
    this->${name}->insert({m_key, m_value});
}
;;

CALL_DESERIALIZE_VALUE:
    this->set_value_${name}(__data);
;;

FUNC_SETTER_FROM_MAP:
void set_value_${name}(__struct_datatype__ *__data) {
    if (NOT_NULL(__data)) {
        __struct_datatype__::const_iterator iter = __data->find("${name}");
        if (iter != __data->end()) {
            void *__ptr = iter->second;
            if (NOT_NULL(__ptr)) {
		${read_map_calls}
            } else {
                this->${name} = nullptr;
            }
        } else {
            this->${name} = nullptr;
        }
    } else {
        this->${name} = nullptr;
    }
}
;;

CALL_NATIVE_SETTER_FROM_MAP:
${type_ptr} __var = static_cast<${type_ptr}>(__ptr);
CHECK_CAST(__var, TYPE_NAME(void *), TYPE_NAME(${type}));
this->${name} = __var;
;;

CALL_TYPE_LIST_SETTER_FROM_MAP:
std::vector<${type_ptr}> *__var = deserialize_list_${m_name}(__ptr);
CHECK_NOT_NULL(__var);
this->${name} = __var;
;;

CALL_TYPE_MAP_SETTER_FROM_MAP:
std::unordered_map<${key_type}, ${value_type_ptr}> *__var = deserialize_map_${m_name}(__ptr);
CHECK_NOT_NULL(__var);
this->${name} = __var;
;;

CALL_TYPE_SETTER_FROM_MAP:
${type_ptr} __var = deserialize_${type}(__ptr);
CHECK_NOT_NULL(__var);
this->${name} = __var;
;;

FUNC_SETTER_TO_MAP:
void set_map_${name}(__struct_datatype__ *__data) {
    CHECK_NOT_NULL(__data);
    if (NOT_NULL(this->${name})) {
	${set_map_calls}	
    }
}
;;

FUNC_FREE_DATA_PTR:
void free_data_ptr(__struct_datatype__ *__data, bool allocated) override {
	__struct_datatype__::iterator iter;
	${free_data_calls}
	__data->clear();
	CHECK_AND_FREE(__data);
}
;;

CALL_FREE_NATIVE_DATA_PTR:
iter = __data->find("${name}");
if (iter != __data->end()) {
	if (NOT_NULL(iter->second)) {
		void *__ptr = iter->second;
		if (allocated) {
			FREE_PTR(__ptr);
		}
	}
}
;;

CALL_FREE_TYPE_DATA_PTR:
iter = __data->find("${name}");
if (iter != __data->end()) {
	if (NOT_NULL(iter->second)) {
		${type_ptr} __ptr = static_cast<${type_ptr}>(iter->second);
	
		if (allocated) {
			CHECK_AND_FREE(__ptr);
		}
	}
}
;;

CALL_FREE_NATIVE_LIST_DATA_PTR:
iter = __data->find("${name}");
if (iter != __data->end()) {
	if (NOT_NULL(iter->second)) {
		void *__ptr = iter->second;
		std::vector<${type_ptr}> *__v_ptr = static_cast<std::vector<${type_ptr}> *>(__ptr);
		CHECK_CAST(__v_ptr, TYPE_NAME(void), TYPE_NAME(vector));
		if (allocated) {
			FREE_NATIVE_LIST(__v_ptr);
		} else {
			CHECK_AND_FREE(__v_ptr);
		}
	}
}
;;

CALL_FREE_TYPE_LIST_DATA_PTR:
iter = __data->find("${name}");
if (iter != __data->end()) {
	if (NOT_NULL(iter->second)) {
		void *__ptr = iter->second;
		std::vector<${type_ptr}> *__v_ptr = static_cast<std::vector<${type_ptr}> *>(__ptr);
		CHECK_CAST(__v_ptr, TYPE_NAME(void), TYPE_NAME(vector));
		if (allocated) {
			FREE_TYPE_LIST(__v_ptr);
		} else {
			CHECK_AND_FREE(__v_ptr);
		}
	}
}
;;

CALL_FREE_NATIVE_MAP_DATA_PTR:
iter = __data->find("${name}");
if (iter != __data->end()) {
	if (NOT_NULL(iter->second)) {
		void *__ptr = iter->second;
		std::unordered_map<${key_type}, ${value_type_ptr}> *__m_ptr = static_cast<std::unordered_map<${key_type}, ${value_type_ptr}> *>(__ptr);
		CHECK_CAST(__m_ptr, TYPE_NAME(void), TYPE_NAME(unordered_map));
		if (allocated) {
			FREE_NATIVE_MAP(__m_ptr);
		} else {
			CHECK_AND_FREE(__m_ptr);
		}
	}
}
;;

CALL_FREE_TYPE_MAP_DATA_PTR:
iter = __data->find("${name}");
if (iter != __data->end()) {
	if (NOT_NULL(iter->second)) {
		void *__ptr = iter->second;
		std::unordered_map<${key_type}, ${value_type_ptr}> *__m_ptr = static_cast<std::unordered_map<${key_type}, ${value_type_ptr}> *>(__ptr);
		CHECK_CAST(__m_ptr, TYPE_NAME(void), TYPE_NAME(unordered_map));
		if (allocated) {
			FREE_NATIVE_MAP(__m_ptr);
		} else {
			CHECK_AND_FREE(__m_ptr);
		}
	}
}
;;

CALL_SETTER_TO_MAP:
this->set_map_${name}(__data);
;;

CALL_NATIVE_SETTER_TO_MAP:
__data->insert({"${name}", this->${name}});
;;

CALL_TYPE_SETTER_TO_MAP:
void *__ptr = serialize_${type}(this->${name});
CHECK_NOT_NULL(__ptr);
__data->insert({"${name}", __ptr});
;;

CALL_TYPE_LIST_SETTER_TO_MAP:
void *__ptr = serialize_list_${m_name}(this->${name});
CHECK_NOT_NULL(__ptr);
__data->insert({"${name}", __ptr});
;;

CALL_TYPE_MAP_SETTER_TO_MAP:
void *__ptr = serialize_map_${m_name}(this->${name});
CHECK_NOT_NULL(__ptr);
__data->insert({"${name}", __ptr});
;;

FUNC_SERIALIZE:
__struct_datatype__ *serialize() override {
    __struct_datatype__ *__data = new __struct_datatype__();
    CHECK_ALLOC(__data, TYPE_NAME(__struct_datatype__));
    ${set_map_calls}
    return __data;
}
;;

FUNC_DESERIALIZE:
void deserialize(__struct_datatype__ *__data) override {
    CHECK_NOT_NULL(__data);
    ${read_map_calls}
    this->__data = __data;
}
;;

FUNC_TYPE_SERIALIZER:
__struct_datatype__ *serialize_${name}(${type_ptr} __value) {
    CHECK_NOT_NULL(__value);
    __struct_datatype__ *__data = __value->serialize();
    CHECK_NOT_NULL(__data);
    return __data;
}
;;

FUNC_TYPE_DESERIALIZER:
${type_ptr} deserialize_${name}(void *__input) {
    CHECK_NOT_NULL(__input);
    __struct_datatype__ *__value = static_cast<__struct_datatype__ *>(__input);
    CHECK_CAST(__value, TYPE_NAME(void *), TYPE_NAME(__struct_datatype__));
    ${type_ptr} __data = new ${type}(__value);
    CHECK_ALLOC(__data, TYPE_NAME(${type}));
    return __data;
}
;;

FUNC_TYPE_LIST_SERIALIZER:
std::vector<__struct_datatype__ *> *serialize_list_${name}(std::vector<${type_ptr}> *__value) {
    CHECK_NOT_EMPTY_P(__value);
    std::vector<__struct_datatype__ *> *__list = new std::vector<__struct_datatype__ *>();
    CHECK_ALLOC(__list, TYPE_NAME(vector));
    for (${type_ptr} rec : *(__value)) {
        CHECK_NOT_NULL(rec);
        __struct_datatype__ *rv = this->serialize_${type}(rec);
        CHECK_NOT_NULL(rv);
        __list->push_back(rv);
    }
    return __list;
}
;;

FUNC_TYPE_LIST_DESERIALIZER:
std::vector<${type_ptr}> *deserialize_list_${name}(void *__input) {
	CHECK_NOT_NULL(__input);
	std::vector<__struct_datatype__ *> *__value = static_cast<std::vector<__struct_datatype__ *> *>( __input);
	CHECK_CAST(__value, TYPE_NAME(void *), TYPE_NAME(vector));

	std::vector<${type_ptr}> *__list = new std::vector<${type_ptr}>();
	CHECK_ALLOC(__list, TYPE_NAME(vector));
	for( __struct_datatype__ *v : *__value) {
		CHECK_NOT_NULL(v);
		${type_ptr} __tv = deserialize_${type}(v);
		CHECK_NOT_NULL(__tv);
		__list->push_back(__tv);
	}
	return __list;
}
;;

FUNC_TYPE_MAP_SERIALIZER:
std::unordered_map<${key_type}, __struct_datatype__ *> *serialize_map_${name}(std::unordered_map<${key_type}, ${value_type_ptr}> *__i_map) {
    CHECK_NOT_EMPTY_P(__i_map);
    std::unordered_map<${key_type}, __struct_datatype__ *> *__map = new std::unordered_map<${key_type}, __struct_datatype__ *>();
    CHECK_ALLOC(__map, TYPE_NAME(unordered_map));

    std::unordered_map<${key_type}, ${value_type_ptr}>::iterator iter;
    for(iter = __i_map->begin(); iter != __i_map->end(); iter++) {
        const ${key_type} key = iter->first;
        ${value_type_ptr} value = iter->second;
        CHECK_NOT_NULL(value);
        __struct_datatype__ *rv = this->serialize_${value_type}(value);
        CHECK_NOT_NULL(rv);
        __map->insert({key, rv});
    }
    return __map;
}
;;

FUNC_TYPE_MAP_DESERIALIZER:
std::unordered_map<${key_type}, ${value_type_ptr}> *deserialize_map_${name}(void *__input) {
	CHECK_NOT_NULL(__input);
	std::unordered_map<${key_type}, __struct_datatype__ *> *__value = static_cast<std::unordered_map<${key_type}, __struct_datatype__ *> *>( __input);
	CHECK_CAST(__value, TYPE_NAME(void *), TYPE_NAME(unordered_map));
	
	std::unordered_map<${key_type}, ${value_type_ptr}> *__map = new std::unordered_map<${key_type}, ${value_type_ptr}>();
	CHECK_ALLOC(__map, TYPE_NAME(unordered_map));

	std::unordered_map<${key_type}, __struct_datatype__ *>::iterator iter;
	for (iter = __value->begin(); iter != __value->end(); iter++) {
		${value_type_ptr} __tv = deserialize_${value_type}(iter->second);
		CHECK_NOT_NULL(__tv);
		__map->insert({iter->first, __tv});
	}
	return __map;
}
;;

FUNC_CONSTRUCTOR_WRITABLE:
${name}() {
    this->__is_allocated = true;
    ${variable_inits}
}
;;

FUNC_CONSTRUCTOR_READABLE:
${name}(__struct_datatype__ *__data) {
    CHECK_NOT_NULL(__data);
    this->__is_allocated = false;
    ${variable_inits}
    this->deserialize(__data);
}
;;

FUNC_DESTRUCTOR:
~${name}() {
    	${variable_frees}
	__base_type::free_data_ptr();
}
;;

INCLUDE_BASE:
#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"

${includes}

using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;

;;

NAMESPACE:
namespace ${name} {
    ${nested}
}
;;

CLASS_DEF:
class ${name} ${parent} {
private:
    ${declarations}

    ${private_functions}
public:
    ${public_functions}
};
;;

FILE_COMMENT:
/*!
 *  Auto-generated types for schema definition [source schema: ${schema_name}]
 *
 *  Reference Schema Version : ${version}
 *  Generated by : ${username}
 *  Generated on : ${date}
 */
;;

FILE_DEF:
${header}

#ifndef ${guard_name}
#define ${guard_name}
${includes}

${body}
#endif // ${guard_name}
;;
