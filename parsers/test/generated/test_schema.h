/*!
 *  Auto-generated types for schema definition [source schema: test_schema]
 *
 *  Reference Schema Version : 0001.0000
 *  Generated by : subho
 *  Generated on : 2016-12-26 19:20:01.320
 */


#ifndef TEST_SCHEMA_H
#define TEST_SCHEMA_H
#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"

#include "test_type.h"
#include "test_ref_type.h"


using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;



namespace com {
    namespace wookler {
    namespace test {
    class test_schema  : public com::wookler::reactfs::types::__base_type {
private:
    char * key = nullptr;

double * dkey = nullptr;

short * sval = nullptr;

test_ref_type * __map = nullptr;

test_type * __ref = nullptr;



    ${private_functions}
public:
    ${constructor}

    ${destructor}

    void set_key(char * key) {
    this->key = key;
}

char * get_key(void) {
    return this->key;
}

void set_key(string &key) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->key);
    if (!IS_EMPTY(key)) {
        uint32_t __size = name.length() + 1;
        this->key = (char) malloc(sizeof(char) * __size);
        CHECK_ALLOC(this->key, TYPE_NAME(char *));
        memset(this->key, 0, __size);
        memcpy(this->key, key.c_str(), (__size - 1));
    }
}

void set_dkey(double * dkey) {
    this->dkey = dkey;
}

double * get_dkey(void) {
    return this->dkey;
}

void set_dkey(double &dkey) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->dkey);
    this->dkey = (double *)malloc(sizeof(double));
    CHECK_ALLOC(this->dkey, TYPE_NAME(double));
    *(this->dkey) = dkey;
}

void set_sval(short * sval) {
    this->sval = sval;
}

short * get_sval(void) {
    return this->sval;
}

void set_sval(short &sval) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->sval);
    this->sval = (short *)malloc(sizeof(short));
    CHECK_ALLOC(this->sval, TYPE_NAME(short));
    *(this->sval) = sval;
}

test_ref_type * get___map(void) {
    return this->__map;
}

void set___map(test_ref_type * __map) {
    this->__map = __map;
}

void *serialize_test_ref_type(test_ref_type *__value) {
    CHECK_NOT_NULL(__value);
    __struct_datatype__ *__data = __value->serialize();
    CHECK_NOT_NULL(__data);
    return __data;
}

test_ref_type *deserialize_test_ref_type(void *__input) {
    CHECK_NOT_NULL(__input);
    __struct_datatype__ *__value = (__struct_datatype__ *)__input;
    CHECK_CAST(__value, TYPE_NAME(void *), TYPE_NAME(__struct_datatype__));
    test_ref_type *__data = new test_ref_type(false);
    CHECK_ALLOC(__data, TYPE_NAME(test_ref_type));
    __data->deserialize(__value);
    return __data;
}

test_type * get___ref(void) {
    return this->__ref;
}

void set___ref(test_type * __ref) {
    this->__ref = __ref;
}

void *serialize_test_type(test_type *__value) {
    CHECK_NOT_NULL(__value);
    __struct_datatype__ *__data = __value->serialize();
    CHECK_NOT_NULL(__data);
    return __data;
}

test_type *deserialize_test_type(void *__input) {
    CHECK_NOT_NULL(__input);
    __struct_datatype__ *__value = (__struct_datatype__ *)__input;
    CHECK_CAST(__value, TYPE_NAME(void *), TYPE_NAME(__struct_datatype__));
    test_type *__data = new test_type(false);
    CHECK_ALLOC(__data, TYPE_NAME(test_type));
    __data->deserialize(__value);
    return __data;
}


};

}

}

}

#endif // TEST_SCHEMA_H

