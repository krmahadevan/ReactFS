/*!
 *  Auto-generated types for schema definition [source schema: test_schema]
 *
 *  Reference Schema Version : 0001.0000
 *  Generated by : subho
 *  Generated on : 2016-12-26 18:24:13.488
 */


#ifndef TEST_REF_TYPE_H
#define TEST_REF_TYPE_H

#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"

#include "test_type.h"


using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;


namespace com {
    namespace wookler {
        namespace test {
            class test_ref_type : public com::wookler::reactfs::types::__base_type {
            private:
                char *name = nullptr;

                unordered_map<std::string, test_type *> *r_map = nullptr;


                $ { private_functions }

            public:
                $ { constructor }

                $ { destructor }

                void set_name(char *name) {
                    this->name = name;
                }

                char *get_name(void) {
                    return this->name;
                }

                void set_name(string &name) {
                    PRECONDITION(this->__is_allocated == true);
                    FREE_PTR(this->name);
                    if (!IS_EMPTY(name)) {
                        uint32_t __size = name.length() + 1;
                        this->name = (char) malloc(sizeof(char) * __size);
                        CHECK_ALLOC(this->name, TYPE_NAME(char * ));
                        memset(this->name, 0, __size);
                        memcpy(this->name, name.c_str(), (__size - 1));
                    }
                }

                unordered_map<std::string, test_type *> *get_r_map(void) {
                    return this->r_map;
                }

                void set_r_map(unordered_map<std::string, test_type *> *r_map) {
                    this->r_map = r_map;
                }

                void add_to_r_map(std::string m_key, test_type *m_value) {
                    PRECONDITION(this->__is_allocated == true);
                    if (IS_NULL(this->r_map)) {
                        this->r_map = new std::unordered_map<std::string, test_type *>();
                        CHECK_ALLOC(this->r_map, TYPE_NAME(unordered_map));
                    }
                    this->r_map->insert(m_key, m_value);
                }

                void *serialize_test_type(test_type *__value) {
                    CHECK_NOT_NULL(__value);
                    __struct_datatype__ *__data = __value->serialize();
                    CHECK_NOT_NULL(__data);
                    return __data;
                }

                test_type *deserialize_test_type(void *__input) {
                    CHECK_NOT_NULL(__input);
                    __struct_datatype__ *__value = (__struct_datatype__ *) __input;
                    CHECK_CAST(__value, TYPE_NAME(void * ), TYPE_NAME(__struct_datatype__));
                    test_type *__data = new test_type(false);
                    CHECK_ALLOC(__data, TYPE_NAME(test_type));
                    __data->deserialize(__value);
                    return __data;
                }


            };

        }

    }

}

#endif // TEST_REF_TYPE_H

