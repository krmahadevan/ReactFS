/*!
 *  Auto-generated types for schema definition [source schema: test_schema]
 *
 *  Reference Schema Version : 0001.0000
 *  Generated by : subho
 *  Generated on : 2016-12-27 14:47:36.899
 */


#ifndef TEST_REF_TYPE_H
#define TEST_REF_TYPE_H
#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"

#include "test_type.h"


using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;



namespace com {
	namespace wookler {
		namespace test {
			class test_ref_type  : public com::wookler::reactfs::types::__base_type
			{
			private:
				char * name = nullptr;

				unordered_map<std::string, test_type *> * testRefMap = nullptr;



				void set_value_name ( __struct_datatype__ *__data )
				{
					if ( NOT_NULL ( __data ) ) {
						__struct_datatype__::const_iterator iter = __data->find ( "name" );
						if ( iter != __data->end() ) {
							void *__ptr = iter->second;
							if ( NOT_NULL ( __ptr ) ) {
								char * __var = static_cast<char *> ( __ptr );
								CHECK_CAST ( __var, TYPE_NAME ( void * ), TYPE_NAME ( char ) );
								this->name = __var;

							} else {
								this->name = nullptr;
							}
						} else {
							this->name = nullptr;
						}
					} else {
						this->name = nullptr;
					}
				}

				void set_map_name ( __struct_datatype__ *__data )
				{
					CHECK_NOT_NULL ( __data );
					if ( NOT_NULL ( this->name ) ) {
						__data->insert ( {"name", this->name} );

					}
				}

				void *serialize_test_type ( test_type * __value )
				{
					CHECK_NOT_NULL ( __value );
					__struct_datatype__ *__data = __value->serialize();
					CHECK_NOT_NULL ( __data );
					return __data;
				}

				test_type * deserialize_test_type ( void *__input )
				{
					CHECK_NOT_NULL ( __input );
					__struct_datatype__ *__value = ( __struct_datatype__ * ) __input;
					CHECK_CAST ( __value, TYPE_NAME ( void * ), TYPE_NAME ( __struct_datatype__ ) );
					test_type * __data = new test_type ( __value );
					CHECK_ALLOC ( __data, TYPE_NAME ( test_type ) );
					return __data;
				}

				std::unordered_map<std::string, __struct_datatype__ *> *serialize_map_unordered_map_std__string__test_type___ ( std::unordered_map<std::string, test_type *> *__i_map )
				{
					CHECK_NOT_EMPTY_P ( map );
					std::unordered_map<std::string, __struct_datatype__ *> *__map = new std::unordered_map<std::string, __struct_datatype__ *>();
					CHECK_ALLOC ( __map, TYPE_NAME ( unordered_map ) );

					std::unordered_map<std::string, test_type *>::iterator iter;
					for ( iter = __i_map->begin(); iter != __i_map.end(); iter++ ) {
						const std::string key = iter->first;
						test_type * value = iter->second;
						CHECK_NOT_NULL ( value );
						__struct_datatype__ *rv = this->serialize_test_type ( value );
						CHECK_NOT_NULL ( rv );
						__i_map->insert ( {key, rv} );
					}
					return __map;
				}

				std::unordered_map<std::string, test_type *> *deserialize_map_unordered_map_std__string__test_type___ ( void *__input )
				{
					CHECK_NOT_NULL ( __input );
					std::unordered_map<std::string, __struct_datatype__ *> *__value = ( std::unordered_map<std::string, __struct_datatype__ *> ) __input;
					CHECK_CAST ( __value, TYPE_NAME ( void * ), TYPE_NAME ( unordered_map ) );

					std::unordered_map<std::string, test_type *> __map = new std::unordered_map<std::string, test_type *>();
					CHECK_ALLOC ( __map, TYPE_NAME ( unordered_map ) );

					std::unordered_map<std::string, __struct_datatype__ *>::iterator iter;
					for ( iter = __value->begin(); iter != __value->end(); iter++ ) {
						test_type * __tv = deserialize_test_type ( iter->second );
						CHECK_NOT_NULL ( __tv );
						__map->insert ( {iter->first, __tv} );
					}
					return __map;
				}

				void set_value_testRefMap ( __struct_datatype__ *__data )
				{
					if ( NOT_NULL ( __data ) ) {
						__struct_datatype__::const_iterator iter = __data->find ( "testRefMap" );
						if ( iter != __data->end() ) {
							void *__ptr = iter->second;
							if ( NOT_NULL ( __ptr ) ) {
								std::unordered_map<char, test_type *> *__var = deserialize_map_unordered_map_std__string__test_type___ ( __ptr );
								CHECK_NOT_NULL ( __var );
								this->testRefMap = __var;

							} else {
								this->testRefMap = nullptr;
							}
						} else {
							this->testRefMap = nullptr;
						}
					} else {
						this->testRefMap = nullptr;
					}
				}

				void set_map_testRefMap ( __struct_datatype__ *__data )
				{
					CHECK_NOT_NULL ( __data );
					if ( NOT_NULL ( this->testRefMap ) ) {
						void *__ptr = serialize_map_unordered_map_std__string__test_type___ ( this->testRefMap );
						CHECK_NOT_NULL ( __ptr );
						__data->insert ( {"testRefMap", __ptr} );

					}
				}


			public:
				void set_name ( char * name )
				{
					this->name = name;
				}

				char * get_name ( void )
				{
					return this->name;
				}

				void set_name ( string &name )
				{
					PRECONDITION ( this->__is_allocated == true );
					FREE_PTR ( this->name );
					if ( !IS_EMPTY ( name ) ) {
						uint32_t __size = name.length() + 1;
						this->name = ( char ) malloc ( sizeof ( char ) * __size );
						CHECK_ALLOC ( this->name, TYPE_NAME ( char * ) );
						memset ( this->name, 0, __size );
						memcpy ( this->name, name.c_str(), ( __size - 1 ) );
					}
				}

				unordered_map<std::string, test_type *> * get_testRefMap ( void )
				{
					return this->testRefMap;
				}

				void set_testRefMap ( unordered_map<std::string, test_type *> * testRefMap )
				{
					this->testRefMap = testRefMap;
				}

				void add_to_testRefMap ( std::string m_key, test_type * m_value )
				{
					PRECONDITION ( this->__is_allocated == true );
					if ( IS_NULL ( this->testRefMap ) ) {
						this->testRefMap = new std::unordered_map<std::string, test_type *>();
						CHECK_ALLOC ( this->testRefMap, TYPE_NAME ( unordered_map ) );
					}
					this->testRefMap->insert ( {m_key, m_value} );
				}

				test_ref_type()
				{
					this->__is_allocated = true;
					this->name = nullptr;
					this->testRefMap = nullptr;

				}

				test_ref_type ( __struct_datatype__ *__data )
				{
					CHECK_NOT_NULL ( __data );
					this->__is_allocated = false;
					this->name = nullptr;
					this->testRefMap = nullptr;

					this->deserialize ( __data );
				}

				~test_ref_type()
				{
					if ( this->__is_allocated ) {
						FREE_PTR ( this->name );
					}

					for ( auto kv = this->testRefMap->being(); kv != this->testRefMap->end(); kv++ ) {
						CHECK_AND_FREE ( kv->second );
					}
					this->testRefMap->clear();
					CHECK_AND_FREE ( this->testRefMap );


				}

				void deserialize ( __struct_datatype__ *__data )
				{
					CHECK_NOT_NULL ( __data );
					this->set_value_name ( __data );

					this->set_value_testRefMap ( __data );


				}

				__struct_datatype__ *serialize() override
				{
					__struct_datatype__ *__data = new __struct_datatype__();
					CHECK_ALLOC ( __data, TYPE_NAME ( __struct_datatype__ ) );
					this->set_map_name ( __data );

					this->set_map_testRefMap ( __data );


					return __data;
				}


			};

		}

	}

}

#endif // TEST_REF_TYPE_H

