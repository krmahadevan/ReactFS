/*!
 *  Auto-generated types for schema definition [source schema: test_schema]
 *
 *  Reference Schema Version : 0001.0000
 *  Generated by : subho
 *  Generated on : 2016-12-26 15:12:56.571
 */


#ifndef TEST_REF_TYPE_H
#define TEST_REF_TYPE_H
#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"

#include "test_type.h"


using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;



namespace com {
    namespace wookler {
    namespace test {
    class test_ref_type  : public com::wookler::reactfs::types::__base_type {
private:
    char *name = nullptr;

std::vector<${type} *> *r_map = nullptr;



    ${private_functions}
public:
    ${constructor}

    ${destructor}

    void set_name(char name) {
    this->name = name;
}

void set_name(char name) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->name);
    this->name = (char *)malloc(sizeof(char);
    CHECK_ALLOC(this->name, TYPE_NAME(char));
    *(this->name) = name;
}

char * get_name(void) {
    return this->name;
}

void set_name(string &name) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->name);
    if (!IS_EMPTY(name) {
        uint32_t __size = name.length() + 1;
        this->name = (char) malloc(sizeof(char) * __size);
        CHECK_ALLOC(this->name, TYPE_NAME(char *));
        memset(this->name, 0, __size);
        memcpy(this->name, name.c_str(), (__size - 1));
    }
}

unordered_map<char, test_type *> * get_r_map(void) {
    return this->r_map;
}

void set_r_map(unordered_map r_map) {
    this->r_map = r_map;
}

void add_to_value(${key_type} ${v_key}, ${value_type} *${v_value}) {
    PRECONDITION(this->__is_allocated == true);
    if (IS_NULL(this->value)) {
        this->value = new std::unordered_map<${key_type}, ${value_type} *>();
        CHECK_ALLOC(this->value, TYPE_NAME(unordered_map));
    }
    this->value->insert(${v_key}, ${v_value}});
}

void *serialize_unkown(unkown *__value) {
    CHECK_NOT_NULL(__value);
    __struct_datatype__ *__data = __value->serialize();
    CHECK_NOT_NULL(__data);
    return __data;
}

unkown *deserialize_unkown(void *__input) {
    CHECK_NOT_NULL(__input);
    __struct_datatype__ *__value = (__struct_datatype__ *)__input;
    CHECK_CAST(__value, TYPE_NAME(void *), TYPE_NAME(__struct_datatype__));
    unkown *__data = new unkown(false);
    CHECK_ALLOC(__data, TYPE_NAME(unkown));
    __data->deserialize(__value);
    return __data;
}


};

}

}

}

#endif // TEST_REF_TYPE_H

