/*!
 *  Auto-generated types for schema definition [source schema: test_schema]
 *
 *  Reference Schema Version : 0001.0000
 *  Generated by : subho
 *  Generated on : 2016-12-26 19:20:01.315
 */


#ifndef TEST_REF_TYPE_H
#define TEST_REF_TYPE_H

#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"

#include "test_type.h"


using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;


namespace com {
    namespace wookler {
        namespace test {
            class test_ref_type : public com::wookler::reactfs::types::__base_type {
            private:
                char *name = nullptr;

                unordered_map<std::string, test_type *> *r_map = nullptr;


                $ { private_functions }

            public:
                $ { constructor }

                $ { destructor }

                void set_name(char *name) {
                    this->name = name;
                }

                char *get_name(void) {
                    return this->name;
                }

                void set_name(string &name) {
                    PRECONDITION(this->__is_allocated == true);
                    FREE_PTR(this->name);
                    if (!IS_EMPTY(name)) {
                        uint32_t __size = name.length() + 1;
                        this->name = (char) malloc(sizeof(char) * __size);
                        CHECK_ALLOC(this->name, TYPE_NAME(char * ));
                        memset(this->name, 0, __size);
                        memcpy(this->name, name.c_str(), (__size - 1));
                    }
                }

                unordered_map<std::string, test_type *> *get_r_map(void) {
                    return this->r_map;
                }

                void set_r_map(unordered_map<std::string, test_type *> *r_map) {
                    this->r_map = r_map;
                }

                void add_to_r_map(std::string m_key, test_type *m_value) {
                    PRECONDITION(this->__is_allocated == true);
                    if (IS_NULL(this->r_map)) {
                        this->r_map = new std::unordered_map<std::string, test_type *>();
                        CHECK_ALLOC(this->r_map, TYPE_NAME(unordered_map));
                    }
                    this->r_map->insert(m_key, m_value);
                }

                void *serialize_test_type(test_type *__value) {
                    CHECK_NOT_NULL(__value);
                    __struct_datatype__ *__data = __value->serialize();
                    CHECK_NOT_NULL(__data);
                    return __data;
                }

                test_type *deserialize_test_type(void *__input) {
                    CHECK_NOT_NULL(__input);
                    __struct_datatype__ *__value = (__struct_datatype__ *) __input;
                    CHECK_CAST(__value, TYPE_NAME(void * ), TYPE_NAME(__struct_datatype__));
                    test_type *__data = new test_type(false);
                    CHECK_ALLOC(__data, TYPE_NAME(test_type));
                    __data->deserialize(__value);
                    return __data;
                }

                std::unordered_map<std::string, __struct_datatype__ *> *
                serialize_map_unordered_map_std__string__test_type___(
                        std::unordered_map<std::string, test_type *> *__i_map) {
                    CHECK_NOT_EMPTY_P(map);
                    std::unordered_map<std::string, __struct_datatype__ *> *__map = new std::unordered_map<std::string, __struct_datatype__ *>();
                    CHECK_ALLOC(__map, TYPE_NAME(unordered_map));

                    std::unordered_map<std::string, test_type *>::iterator iter;
                    for (iter = __i_map->begin(); iter != __i_map.end(); iter++) {
                        const std::string key = iter->first;
                        test_type *value = iter->second;
                        CHECK_NOT_NULL(value);
                        __struct_datatype__ *rv = this->serialize_test_type(value);
                        CHECK_NOT_NULL(rv);
                        __i_map->insert({key, rv});
                    }
                    return __map;
                }

                std::unordered_map<std::string, test_type *> *
                deserialize_map_unordered_map_std__string__test_type___(void *__input) {
                    CHECK_NOT_NULL(__input);
                    std::unordered_map<std::string, __struct_datatype__ *> *__value = (std::unordered_map<std::string, __struct_datatype__ *>) __input;
                    CHECK_CAST(__value, TYPE_NAME(void * ), TYPE_NAME(unordered_map));

                    std::unordered_map<std::string, test_type *> __map = new std::unordered_map<std::string, test_type *>();
                    CHECK_ALLOC(__map, TYPE_NAME(unordered_map));

                    std::unordered_map<std::string, __struct_datatype__ *>::iterator iter;
                    for (iter = __value->begin(); iter != __value->end(); iter++) {
                        test_type *__tv = deserialize_test_type(iter->second);
                        CHECK_NOT_NULL(__tv);
                        __map->insert({iter->first, __tv});
                    }
                    return __map;
                }


            };

        }

    }

}

#endif // TEST_REF_TYPE_H

