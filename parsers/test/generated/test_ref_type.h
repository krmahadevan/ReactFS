/*!
 *  Auto-generated types for schema definition [source schema: test_schema]
 *
 *  Reference Schema Version : 0001.0000
 *  Generated by : subho
 *  Generated on : 2017-01-05 12:16:03.743
 */


#ifndef TEST_REF_TYPE_H
#define TEST_REF_TYPE_H
#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"

#include "test_type.h"


using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;



namespace com {
	namespace wookler {
		namespace test {
			/**
			* Generated code for data record type test_ref_type.
			*
			* Note:: Should not be modified as the changes will be lost when the code is re-generated.
			*/
			class test_ref_type  : public com::wookler::reactfs::core::types::__base_type
			{
			private:
				char * name = nullptr;

				unordered_map<std::string, test_type *> * testRefMap = nullptr;



				/**
				* Value name setter from the the serialized data map.
				*
				* @param __data - Serialized data map pointer.
				*/
				void read_value_name ( record_struct *__data )
				{
					if ( NOT_NULL ( __data ) ) {
						const void *__ptr = __data->get_field ( 0 );
						if ( NOT_NULL ( __ptr ) ) {
							// Set the value of name
							const char * __var = static_cast<const char *> ( __ptr );
							CHECK_CAST ( __var, TYPE_NAME ( void * ), TYPE_NAME ( char ) );
							this->name = __var;

						} else {
							this->name = nullptr;
						}
					} else {
						this->name = nullptr;
					}
				}

				/**
				 * Method extracts and set the value of name from
				 * the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void set_serde_name ( mutable_record_struct *__data )
				{
					CHECK_NOT_NULL ( __data );
					if ( NOT_NULL ( this->name ) ) {
						// Add the value of name to the data map.
						{
							const __native_type *ft = get_field_type ( "name" );
							CHECK_NOT_NULL ( ft );
							__data->add_field ( ft->get_index(), this->name );

						}

					}
				}

				/**
				 * Serialize the type value for test_type and add to the data map.
				 *
				 * @param __value - Pointer to the field of type test_type.
				 * @return - Serialized data map instance.
				 */
				mutable_record_struct *serialize_test_type ( test_type * __value )
				{
					CHECK_NOT_NULL ( __value );
					mutable_record_struct *__data = __value->serialize();
					CHECK_NOT_NULL ( __data );
					return __data;
				}

				/**
				 * Deserialize an instance of type test_type from the
				 * passed input data.
				 *
				 * @param __input - Void pointer to input data of type __struct_datatype__
				 * @return - Deserialized instance pointer of type test_type *
				 */
				test_type * deserialize_test_type ( const void *__input )
				{
					CHECK_NOT_NULL ( __input );
					const record_struct *__value = static_cast<const record_struct *> ( __input );
					CHECK_CAST ( __value, TYPE_NAME ( void * ), TYPE_NAME ( record_struct ) );
					test_type * __data = new test_type ( __value );
					CHECK_ALLOC ( __data, TYPE_NAME ( test_type ) );
					return __data;
				}

				/**
				 * Serialize a map instance of key/value type std::string/test_type * from the passed input data.
				 *
				 * @param __i_map - Input map data.
				 * @return - Serialized data map of key/value type unordered_map<std::string, __struct_datatype__ *>
				 */
				std::unordered_map<std::string, mutable_record_struct *> *serialize_map_unordered_map_std__string__test_type___ ( std::unordered_map<std::string, test_type *> *__i_map )
				{
					CHECK_NOT_EMPTY_P ( __i_map );
					std::unordered_map<std::string, mutable_record_struct *> *__map = new std::unordered_map<std::string, mutable_record_struct *>();
					CHECK_ALLOC ( __map, TYPE_NAME ( unordered_map ) );

					std::unordered_map<std::string, test_type *>::iterator iter;
					for ( iter = __i_map->begin(); iter != __i_map->end(); iter++ ) {
						const std::string key = iter->first;
						test_type * value = iter->second;
						CHECK_NOT_NULL ( value );
						mutable_record_struct *rv = this->serialize_test_type ( value );
						CHECK_NOT_NULL ( rv );
						__map->insert ( {key, rv} );
					}
					return __map;
				}

				/**
				 * Deserialize a map instance of key/value type std::string/test_type * from the passed input data.
				 *
				 * @param __input - Void pointer of type unordered_map<std::string, __struct_datatype__ *>
				 * @return - Deserialized map of key/value type unordered_map<std::string, test_type *>
				 */
				std::unordered_map<std::string, test_type *> *deserialize_map_unordered_map_std__string__test_type___ ( const void *__input )
				{
					CHECK_NOT_NULL ( __input );
					const std::unordered_map<std::string, record_struct *> *__value = static_cast<const std::unordered_map<std::string, record_struct *> *> ( __input );
					CHECK_CAST ( __value, TYPE_NAME ( void * ), TYPE_NAME ( unordered_map ) );

					std::unordered_map<std::string, test_type *> *__map = new std::unordered_map<std::string, test_type *>();
					CHECK_ALLOC ( __map, TYPE_NAME ( unordered_map ) );

					std::unordered_map<std::string, record_struct *>::iterator iter;
					for ( iter = __value->begin(); iter != __value->end(); iter++ ) {
						test_type * __tv = deserialize_test_type ( iter->second );
						CHECK_NOT_NULL ( __tv );
						__map->insert ( {iter->first, __tv} );
					}
					return __map;
				}

				/**
				 * Value testRefMap setter from the the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void read_value_testRefMap ( record_struct *__data )
				{
					if ( NOT_NULL ( __data ) ) {
						const void *__ptr = __data->get_field ( $ {field_index} );
						if ( NOT_NULL ( __ptr ) ) {
							// Set the value of map testRefMap
							std::unordered_map<std::string, test_type *> *__var = deserialize_map_unordered_map_std__string__test_type___ ( __ptr );
							CHECK_NOT_NULL ( __var );
							this->testRefMap = __var;

						} else {
							this->testRefMap = nullptr;
						}
					} else {
						this->testRefMap = nullptr;
					}
				}

				/**
				 * Method extracts and set the value of testRefMap from
				 * the serialized data map.
				 *
				 * @param __data - Serialized data map pointer.
				 */
				void set_serde_testRefMap ( mutable_record_struct *__data )
				{
					CHECK_NOT_NULL ( __data );
					if ( NOT_NULL ( this->testRefMap ) ) {
						// Serialize the map testRefMap and add to the data map.
						{
							void *__ptr = serialize_map_unordered_map_std__string__test_type___ ( this->testRefMap );
							CHECK_NOT_NULL ( __ptr );

							const __native_type *ft = get_field_type ( "testRefMap" );
							CHECK_NOT_NULL ( ft );

							__data->add_field ( ft->get_index(), ptr );
						}

					}
				}


			public:
				/**
				* Set the pointer to name.
				*
				* @param name - Pointer of type char *.
				*/
				void set_name ( char * name )
				{
					this->name = name;
				}

				/**
				 * Get the pointer to the property name of type char *.
				 * Returns a const pointer.
				 *
				 * @return char *
				 */
				const char * get_name ( void ) const
				{
					return this->name;
				}

				/**
				 * Set the char buffer value from the specified string.
				 *
				 * Method should only be used when this instance is being
				 * used to create or update a new record instance.
				 *
				 * @param name - String value to set.
				 */
				void set_name ( string &name )
				{
					FREE_PTR ( this->name );
					if ( !IS_EMPTY ( name ) ) {
						uint32_t __size = name.length() + 1;
						this->name = ( char * ) malloc ( sizeof ( char ) * __size );
						CHECK_ALLOC ( this->name, TYPE_NAME ( char * ) );
						memset ( this->name, 0, __size );
						memcpy ( this->name, name.c_str(), ( __size - 1 ) );
					}
				}

				/**
				 * Get the pointer to the property testRefMap of type unordered_map<std::string, test_type *> *.
				 * Returns a const pointer.
				 *
				 * @return unordered_map<std::string, test_type *> *
				 */
				const unordered_map<std::string, test_type *> * get_testRefMap ( void ) const
				{
					return this->testRefMap;
				}

				/**
				 * Set the pointer to testRefMap.
				 *
				 * @param testRefMap - Pointer of type unordered_map<std::string, test_type *> *.
				 */
				void set_testRefMap ( unordered_map<std::string, test_type *> * testRefMap )
				{
					this->testRefMap = testRefMap;
				}

				/**
				 * Add a key/value pair to the map with a type value.
				 * The value is expected to be a pre-allocated ${type} pointer.
				 *
				 * Method should only be used when this instance is being
				 * used to create or update a new record instance.
				 *
				 * @param m_key - std::string key value.
				 * @param m_value - test_type * value pointer.
				 */
				void add_to_testRefMap ( std::string m_key, test_type * m_value )
				{
					PRECONDITION ( this->__is_allocated == true );
					if ( IS_NULL ( this->testRefMap ) ) {
						this->testRefMap = new std::unordered_map<std::string, test_type *>();
						CHECK_ALLOC ( this->testRefMap, TYPE_NAME ( unordered_map ) );
					}
					this->testRefMap->insert ( {m_key, m_value} );
				}

				/**
				 * Empty constructor when creating an instance of test_ref_type for setting data locally.
				 * Should be used to create a new record instance of type test_ref_type.
				 *
				 * @param record_type - Parsed schema definition of this type.
				 */
				test_ref_type ( const __complex_type *record_type )
				{
					CHECK_NOT_NULL ( record_type );
					this->record_type = record_type;
					this->__is_allocated = true;
					this->name = nullptr;
					this->testRefMap = nullptr;

				}

				/**
				 * Create a new read-only instance of test_ref_type and populate the data from the passed
				 * serialized data map.
				 *
				 * @param __data - Serialized data map to load the object data from.
				 */
				test_ref_type ( record_struct *__data )
				{
					CHECK_NOT_NULL ( __data );
					this->name = nullptr;
					this->testRefMap = nullptr;

					this->deserialize ( __data );
				}

				/**
				 * Copy constructor to create a copy instance of test_ref_type.
				 * Copy instances should be used to update existing records.
				 *
				 * @param source - Source instance of test_ref_type to copy from.
				 */
				test_ref_type ( const test_ref_type &source )
				{
					this->__is_allocated = true;
					this->record_type = source.get_record_type();
					CHECK_NOT_NULL ( this->record_type );

					this->name = nullptr;
					this->testRefMap = nullptr;

					// Set name from the source value.
					if ( NOT_NULL ( source.name ) ) {
						string __name = string ( source.name );
						this->set_name ( __name );
					}

// Deserialize the map testRefMap from the source value.
					if ( NOT_EMPTY_P ( source.testRefMap ) ) {
						std::unordered_map<std::string, test_type *> *__map = new std::unordered_map<std::string, test_type *>();
						CHECK_ALLOC ( __map, TYPE_NAME ( unordered_map ) );

						std::unordered_map<std::string, test_type * >::iterator iter;
						for ( iter = source.testRefMap->begin(); iter != source.testRefMap->end(); iter++ ) {
							CHECK_NOT_NULL ( iter->second );
							test_type * __tv = new test_type ( *iter->second );
							CHECK_ALLOC ( __tv, TYPE_NAME ( test_type ) );
							__map->insert ( {iter->first, __tv} );
						}
						this->testRefMap = __map;
					}


				}

				/**
				 * Copy constructor to create a copy instance of test_ref_type.
				 * Copy instances should be used to update existing records.
				 *
				 * @param source - Source instance of test_ref_type to copy from.
				 */
				test_ref_type ( const test_ref_type *source )
				{
					this->__is_allocated = true;
					this->record_type = source->get_record_type();
					CHECK_NOT_NULL ( this->record_type );

					this->name = nullptr;
					this->testRefMap = nullptr;

					// Set name from the source value.
					if ( NOT_NULL ( source->name ) ) {
						string __name = string ( source->name );
						this->set_name ( __name );
					}

// Deserialize the map testRefMap from the source value.
					if ( NOT_EMPTY_P ( source->testRefMap ) ) {
						std::unordered_map<std::string, test_type *> *__map = new std::unordered_map<std::string, test_type *>();
						CHECK_ALLOC ( __map, TYPE_NAME ( unordered_map ) );

						std::unordered_map<std::string, test_type * >::iterator iter;
						for ( iter = source->testRefMap->begin(); iter != source->testRefMap->end(); iter++ ) {
							CHECK_NOT_NULL ( iter->second );
							test_type * __tv = new test_type ( iter->second );
							CHECK_ALLOC ( __tv, TYPE_NAME ( test_type ) );
							__map->insert ( {iter->first, __tv} );
						}
						this->testRefMap = __map;
					}


				}

				/**
				 * Descructor for test_ref_type
				 */
				~test_ref_type()
				{
					if ( this->__is_allocated ) {
						FREE_PTR ( this->name );
					}

					FREE_TYPE_MAP ( this->testRefMap );


					__base_type::free_data_ptr();
				}

				/**
				 * Deserialize this type instance from the passed data map.
				 *
				 * @param __data - Serialized data record instance to load this type from.
				 */
				void deserialize ( const record_struct *__data ) override
				{
					CHECK_NOT_NULL ( __data );

					this->record_type = __data->get_record_type();
					CHECK_NOT_NULL ( this->record_type );
					this->__is_allocated = false;

					// Set the value of name from the serialized data map.
					this->read_value_name ( __data );

					// Set the value of testRefMap from the serialized data map.
					this->read_value_testRefMap ( __data );



					this->__data = __data;
				}

				/**
				 * Serialize this type instance into a data map instance.
				 *
				 * @return - Serialized data record instance.
				 */
				mutable_record_struct *serialize() override
				{
					mutable_record_struct *__data = new mutable_record_struct ( this->record_type );
					CHECK_ALLOC ( __data, TYPE_NAME ( mutable_record_struct ) );
					// Call the method to add the value of name to the serialized data map.
					this->set_serde_name ( __data );

// Call the method to add the value of testRefMap to the serialized data map.
					this->set_serde_testRefMap ( __data );


					return __data;
				}


			};

		}

	}

}

#endif // TEST_REF_TYPE_H

