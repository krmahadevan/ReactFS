/*!
 *  Auto-generated types for schema definition [source schema: test_schema]
 *
 *  Reference Schema Version : 0001.0000
 *  Generated by : subho
 *  Generated on : 2016-12-27 13:12:55.846
 */


#ifndef TEST_TYPE_H
#define TEST_TYPE_H

#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"


using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;


namespace com {
    namespace wookler {
        namespace test {
            class test_type : public com::wookler::reactfs::types::__base_type {
            private:
                char *ss = nullptr;

                double *dd = nullptr;

                float *fv = nullptr;

                vector<char *> *ll = nullptr;

                unordered_map<double, char *> *str_map = nullptr;


                void set_value_ss(__struct_datatype__ *__data) {
                    if (NOT_NULL(__data)) {
                        __struct_datatype__::const_iterator iter = __data->find("ss");
                        if (iter != __data->end()) {
                            void *__ptr = iter->second;
                            if (NOT_NULL(__ptr)) {
                                char *__var = static_cast<char *>(__ptr);
                                CHECK_CAST(__var, TYPE_NAME(void * ), TYPE_NAME(char));
                                this->ss = __var;

                            } else {
                                this->ss = nullptr;
                            }
                        } else {
                            this->ss = nullptr;
                        }
                    } else {
                        this->ss = nullptr;
                    }
                }

                void set_map_ss(__struct_datatype__ *__data) {
                    CHECK_NOT_NULL(__data);
                    if (NOT_NULL(this->ss)) {
                        __data->insert({"ss", this->ss});

                    }
                }

                void set_value_dd(__struct_datatype__ *__data) {
                    if (NOT_NULL(__data)) {
                        __struct_datatype__::const_iterator iter = __data->find("dd");
                        if (iter != __data->end()) {
                            void *__ptr = iter->second;
                            if (NOT_NULL(__ptr)) {
                                double *__var = static_cast<double *>(__ptr);
                                CHECK_CAST(__var, TYPE_NAME(void * ), TYPE_NAME(double));
                                this->dd = __var;

                            } else {
                                this->dd = nullptr;
                            }
                        } else {
                            this->dd = nullptr;
                        }
                    } else {
                        this->dd = nullptr;
                    }
                }

                void set_map_dd(__struct_datatype__ *__data) {
                    CHECK_NOT_NULL(__data);
                    if (NOT_NULL(this->dd)) {
                        __data->insert({"dd", this->dd});

                    }
                }

                void set_value_fv(__struct_datatype__ *__data) {
                    if (NOT_NULL(__data)) {
                        __struct_datatype__::const_iterator iter = __data->find("fv");
                        if (iter != __data->end()) {
                            void *__ptr = iter->second;
                            if (NOT_NULL(__ptr)) {
                                float *__var = static_cast<float *>(__ptr);
                                CHECK_CAST(__var, TYPE_NAME(void * ), TYPE_NAME(float));
                                this->fv = __var;

                            } else {
                                this->fv = nullptr;
                            }
                        } else {
                            this->fv = nullptr;
                        }
                    } else {
                        this->fv = nullptr;
                    }
                }

                void set_map_fv(__struct_datatype__ *__data) {
                    CHECK_NOT_NULL(__data);
                    if (NOT_NULL(this->fv)) {
                        __data->insert({"fv", this->fv});

                    }
                }

                void set_value_ll(__struct_datatype__ *__data) {
                    if (NOT_NULL(__data)) {
                        __struct_datatype__::const_iterator iter = __data->find("ll");
                        if (iter != __data->end()) {
                            void *__ptr = iter->second;
                            if (NOT_NULL(__ptr)) {
                                vector<char *> *__var = static_cast<vector<char *> *>(__ptr);
                                CHECK_CAST(__var, TYPE_NAME(void * ), TYPE_NAME(vector<char *>));
                                this->ll = __var;

                            } else {
                                this->ll = nullptr;
                            }
                        } else {
                            this->ll = nullptr;
                        }
                    } else {
                        this->ll = nullptr;
                    }
                }

                void set_map_ll(__struct_datatype__ *__data) {
                    CHECK_NOT_NULL(__data);
                    if (NOT_NULL(this->ll)) {
                        __data->insert({"ll", this->ll});

                    }
                }

                void set_value_str_map(__struct_datatype__ *__data) {
                    if (NOT_NULL(__data)) {
                        __struct_datatype__::const_iterator iter = __data->find("str_map");
                        if (iter != __data->end()) {
                            void *__ptr = iter->second;
                            if (NOT_NULL(__ptr)) {
                                unordered_map<double, char *> *__var = static_cast<unordered_map<double, char *> *>(__ptr);
                                CHECK_CAST(__var, TYPE_NAME(void * ), TYPE_NAME(unordered_map<double, char *>));
                                this->str_map = __var;

                            } else {
                                this->str_map = nullptr;
                            }
                        } else {
                            this->str_map = nullptr;
                        }
                    } else {
                        this->str_map = nullptr;
                    }
                }

                void set_map_str_map(__struct_datatype__ *__data) {
                    CHECK_NOT_NULL(__data);
                    if (NOT_NULL(this->str_map)) {
                        __data->insert({"str_map", this->str_map});

                    }
                }


            public:
                $ { constructor }

                $ { destructor }

                void set_ss(char *ss) {
                    this->ss = ss;
                }

                char *get_ss(void) {
                    return this->ss;
                }

                void set_ss(string &ss) {
                    PRECONDITION(this->__is_allocated == true);
                    FREE_PTR(this->ss);
                    if (!IS_EMPTY(ss)) {
                        uint32_t __size = name.length() + 1;
                        this->ss = (char) malloc(sizeof(char) * __size);
                        CHECK_ALLOC(this->ss, TYPE_NAME(char * ));
                        memset(this->ss, 0, __size);
                        memcpy(this->ss, ss.c_str(), (__size - 1));
                    }
                }

                void set_dd(double *dd) {
                    this->dd = dd;
                }

                double *get_dd(void) {
                    return this->dd;
                }

                void set_dd(double &dd) {
                    PRECONDITION(this->__is_allocated == true);
                    FREE_PTR(this->dd);
                    this->dd = (double *) malloc(sizeof(double));
                    CHECK_ALLOC(this->dd, TYPE_NAME(double));
                    *(this->dd) = dd;
                }

                void set_fv(float *fv) {
                    this->fv = fv;
                }

                float *get_fv(void) {
                    return this->fv;
                }

                void set_fv(float &fv) {
                    PRECONDITION(this->__is_allocated == true);
                    FREE_PTR(this->fv);
                    this->fv = (float *) malloc(sizeof(float));
                    CHECK_ALLOC(this->fv, TYPE_NAME(float));
                    *(this->fv) = fv;
                }

                vector<char *> *get_ll(void) {
                    return this->ll;
                }

                void set_ll(vector<char *> *ll) {
                    this->ll = ll;
                }

                void add_to_ll(string &ll) {
                    PRECONDITION(this->__is_allocated == true);
                    if (IS_NULL(this->ll)) {
                        this->ll = new std::vector<char *>();
                        CHECK_ALLOC(this->ll, TYPE_NAME(vector));
                    }
                    if (!IS_EMPTY(ll)) {
                        uint32_t __size = name.length() + 1;
                        char *__var = (char *) malloc(sizeof(char) * __size);
                        CHECK_ALLOC(__var, TYPE_NAME(char * ));
                        memset(__var, 0, __size);
                        memcpy(__var, ll.c_str(), (__size - 1));
                        this->ll->push_back(var);
                    }
                }

                unordered_map<double, char *> *get_str_map(void) {
                    return this->str_map;
                }

                void set_str_map(unordered_map<double, char *> *str_map) {
                    this->str_map = str_map;
                }

                void add_to_str_map(double m_key, string &m_value) {
                    PRECONDITION(this->__is_allocated == true);
                    if (IS_NULL(this->str_map)) {
                        this->str_map = new std::unordered_map<double, char *>();
                        CHECK_ALLOC(this->str_map, TYPE_NAME(unordered_map));
                    }
                    CHECK_NOT_EMPTY(m_value);
                    uint32_t __size = (m_value.length() + 1) * sizeof(char);
                    char *__var = (char *) malloc(sizeof(char) * __size);
                    CHECK_ALLOC(__var, TYPE_NAME(char * ));
                    memset(__var, 0, __size);
                    memcpy(__var, m_value.c_str(), (__size - 1));
                    this->str_map->insert({m_key, __var});
                }

                void deserialize(__struct_datatype__ *__data) {
                    CHECK_NOT_NULL(__data);
                    this->set_value_ss(__data);

                    this->set_value_dd(__data);

                    this->set_value_fv(__data);

                    this->set_value_ll(__data);

                    this->set_value_str_map(__data);


                }

                __struct_datatype__ *serialize() override {
                    __struct_datatype__ *__data = new __struct_datatype__();
                    CHECK_ALLOC(__data, TYPE_NAME(__struct_datatype__));
                    this->set_map_ss(__data);

                    this->set_map_dd(__data);

                    this->set_map_fv(__data);

                    this->set_map_ll(__data);

                    this->set_map_str_map(__data);


                    return __data;
                }


            };

        }

    }

}

#endif // TEST_TYPE_H

