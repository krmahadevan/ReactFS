/*!
 *  Auto-generated types for schema definition [source schema: test_schema]
 *
 *  Reference Schema Version : 0001.0000
 *  Generated by : subho
 *  Generated on : 2016-12-26 18:24:13.490
 */


#ifndef TEST_TYPE_H
#define TEST_TYPE_H

#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"


using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;


namespace com {
    namespace wookler {
        namespace test {
            class test_type : public com::wookler::reactfs::types::__base_type {
            private:
                char *ss = nullptr;

                double *dd = nullptr;

                float *fv = nullptr;

                vector<char *> *ll = nullptr;

                unordered_map<double, char *> *str_map = nullptr;


                $ { private_functions }

            public:
                $ { constructor }

                $ { destructor }

                void set_ss(char *ss) {
                    this->ss = ss;
                }

                char *get_ss(void) {
                    return this->ss;
                }

                void set_ss(string &ss) {
                    PRECONDITION(this->__is_allocated == true);
                    FREE_PTR(this->ss);
                    if (!IS_EMPTY(ss)) {
                        uint32_t __size = name.length() + 1;
                        this->ss = (char) malloc(sizeof(char) * __size);
                        CHECK_ALLOC(this->ss, TYPE_NAME(char * ));
                        memset(this->ss, 0, __size);
                        memcpy(this->ss, ss.c_str(), (__size - 1));
                    }
                }

                void set_dd(double *dd) {
                    this->dd = dd;
                }

                double *get_dd(void) {
                    return this->dd;
                }

                void set_dd(double &dd) {
                    PRECONDITION(this->__is_allocated == true);
                    FREE_PTR(this->dd);
                    this->dd = (double *) malloc(sizeof(double));
                    CHECK_ALLOC(this->dd, TYPE_NAME(double));
                    *(this->dd) = dd;
                }

                void set_fv(float *fv) {
                    this->fv = fv;
                }

                float *get_fv(void) {
                    return this->fv;
                }

                void set_fv(float &fv) {
                    PRECONDITION(this->__is_allocated == true);
                    FREE_PTR(this->fv);
                    this->fv = (float *) malloc(sizeof(float));
                    CHECK_ALLOC(this->fv, TYPE_NAME(float));
                    *(this->fv) = fv;
                }

                vector<char *> *get_ll(void) {
                    return this->ll;
                }

                void set_ll(vector<char *> *ll) {
                    this->ll = ll;
                }

                void add_to_ll(string &ll) {
                    PRECONDITION(this->__is_allocated == true);
                    if (IS_NULL(this->ll)) {
                        this->ll = new std::vector<char *>();
                        CHECK_ALLOC(this->ll, TYPE_NAME(vector));
                    }
                    if (!IS_EMPTY(ll)) {
                        uint32_t __size = name.length() + 1;
                        char *__var = (char *) malloc(sizeof(char) * __size);
                        CHECK_ALLOC(__var, TYPE_NAME(char * ));
                        memset(__var, 0, __size);
                        memcpy(__var, ll.c_str(), (__size - 1));
                        this->ll->push_back(var);
                    }
                }

                unordered_map<double, char *> *get_str_map(void) {
                    return this->str_map;
                }

                void set_str_map(unordered_map<double, char *> *str_map) {
                    this->str_map = str_map;
                }

                void add_to_str_map(double m_key, string &m_value) {
                    PRECONDITION(this->__is_allocated == true);
                    if (IS_NULL(this->str_map)) {
                        this->str_map = new std::unordered_map<double, char *>();
                        CHECK_ALLOC(this->str_map, TYPE_NAME(unordered_map));
                    }
                    CHECK_NOT_EMPTY(m_value);
                    uint32_t __size = (m_value.length() + 1) * sizeof(char);
                    char *__var = (char *) malloc(sizeof(char) * __size);
                    CHECK_ALLOC(__var, TYPE_NAME(char * ));
                    memset(__var, 0, __size);
                    memcpy(__var, m_value.c_str(), (__size - 1));
                    this->str_map->insert(m_key, __var
                }

                );
            }


        };

    }

}

}

#endif // TEST_TYPE_H

