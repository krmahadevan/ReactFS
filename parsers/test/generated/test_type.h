/*!
 *  Auto-generated types for schema definition [source schema: test_schema]
 *
 *  Reference Schema Version : 0001.0000
 *  Generated by : subho
 *  Generated on : 2016-12-26 15:12:56.576
 */


#ifndef TEST_TYPE_H
#define TEST_TYPE_H
#include "types/includes/type_defs.h"
#include "types/includes/__base_type.h"



using namespace REACTFS_NS_COMMON_PREFIX;
using namespace REACTFS_NS_CORE_PREFIX::types;



namespace com {
    namespace wookler {
    namespace test {
    class test_type  : public com::wookler::reactfs::types::__base_type {
private:
    char *ss = nullptr;

double *dd = nullptr;

float *fv = nullptr;

std::vector<char *> *ll = nullptr;



    ${private_functions}
public:
    ${constructor}

    ${destructor}

    void set_ss(char ss) {
    this->ss = ss;
}

void set_ss(char ss) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->ss);
    this->ss = (char *)malloc(sizeof(char);
    CHECK_ALLOC(this->ss, TYPE_NAME(char));
    *(this->ss) = ss;
}

char * get_ss(void) {
    return this->ss;
}

void set_ss(string &ss) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->ss);
    if (!IS_EMPTY(ss) {
        uint32_t __size = name.length() + 1;
        this->ss = (char) malloc(sizeof(char) * __size);
        CHECK_ALLOC(this->ss, TYPE_NAME(char *));
        memset(this->ss, 0, __size);
        memcpy(this->ss, ss.c_str(), (__size - 1));
    }
}

void set_dd(double dd) {
    this->dd = dd;
}

void set_dd(double dd) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->dd);
    this->dd = (double *)malloc(sizeof(double);
    CHECK_ALLOC(this->dd, TYPE_NAME(double));
    *(this->dd) = dd;
}

double * get_dd(void) {
    return this->dd;
}

void set_fv(float fv) {
    this->fv = fv;
}

void set_fv(float fv) {
    PRECONDITION(this->__is_allocated == true);
    FREE_PTR(this->fv);
    this->fv = (float *)malloc(sizeof(float);
    CHECK_ALLOC(this->fv, TYPE_NAME(float));
    *(this->fv) = fv;
}

float * get_fv(void) {
    return this->fv;
}

vector<char *> * get_ll(void) {
    return this->ll;
}

void set_ll(vector ll) {
    this->ll = ll;
}

void add_to_ll(char &ll) {
    PRECONDITION(this->__is_allocated == true);
    if (IS_NULL(this->ll)) {
        this->ll = new std::vector<char *>();
        CHECK_ALLOC(this->ll, TYPE_NAME(vector));
    }
    char *__var = (char *)malloc(sizeof(char));
    CHECK_ALLOC(__var, TYPE_NAME(char));
    *__var = ll;
    this->ll->push_back(__var);
}

void add_to_ll(string &ll) {
    PRECONDITION(this->__is_allocated == true);
    if (IS_NULL(this->ll)) {
        this->ll = new std::vector<char *>();
        CHECK_ALLOC(this->ll, TYPE_NAME(vector));
    }
    if (!IS_EMPTY(ll) {
        uint32_t __size = name.length() + 1;
        char *__var = (char *)malloc(sizeof(char) * __size);
        CHECK_ALLOC(__var, TYPE_NAME(char *));
        memset(__var, 0, __size);
        memcpy(__var, ll.c_str(), (__size - 1));
        this->ll->push_back(var);
    }
}


};

}

}

}

#endif // TEST_TYPE_H

